# Checkin StrongRef Refactor Plan

## Overview
Refactor checkin records to use strongrefs pointing to separate community address records, both stored on the user's PDS.

## Record Structure

### Address Record
**Collection:** `community.lexicon.location.address`
**Storage:** User's PDS

```json
{
  "$type": "community.lexicon.location.address",
  "name": "Caf√© de Plek",
  "street": "Julianalaan 1", 
  "locality": "Voorburg",
  "region": "ZH",
  "country": "NL",
  "postalCode": "2273JA"
}
```

### Checkin Record  
**Collection:** `app.dropanchor.checkin`
**Storage:** User's PDS

```json
{
  "$type": "app.dropanchor.checkin",
  "text": "Meeting Sarah for drinks! üçª",
  "createdAt": "2025-06-29T19:30:00Z",
  "addressRef": {
    "uri": "at://did:plc:user123/community.lexicon.location.address/abc123",
    "cid": "bafyreigh2akiscaildc..."
  },
  "coordinates": {
    "$type": "community.lexicon.location.geo", 
    "latitude": "52.0705",
    "longitude": "4.3007"
  }
}
```

## Creation Workflow

### Step 1: Create Address Record
```swift
let addressResponse = try await atproto.com.atproto.repo.createRecord(
    repo: userDid,
    collection: "community.lexicon.location.address",
    record: addressRecord
)
// Returns: { uri, cid, validationStatus }
```

### Step 2: Create Checkin with StrongRef
```swift
let checkinRecord = CheckinRecord(
    text: checkinText,
    createdAt: ISO8601DateFormatter().string(from: Date()),
    addressRef: StrongRef(
        uri: addressResponse.uri,      // from step 1
        cid: addressResponse.cid       // from step 1
    ),
    coordinates: coordinates
)

let checkinResponse = try await atproto.com.atproto.repo.createRecord(
    repo: userDid,
    collection: "app.dropanchor.checkin", 
    record: checkinRecord
)
```

## AT Protocol Compliance

### CID Generation
- **Automatic:** Generated by `com.atproto.repo.createRecord`
- **Algorithm:** DAG-CBOR encoding + SHA-256
- **Format:** `bafyrei...` (CIDv1 with base32 encoding)

### StrongRef Structure
Per AT Protocol specification:
```typescript
interface StrongRef {
  uri: string;    // AT URI: at://did/collection/rkey
  cid: string;    // Content hash for verification
}
```

### URI Format
```
at://did:plc:user123/community.lexicon.location.address/abc123
‚îÇ   ‚îÇ              ‚îÇ                                   ‚îÇ
‚îÇ   ‚îÇ              ‚îÇ                                   ‚îî‚îÄ rkey (record key)
‚îÇ   ‚îÇ              ‚îî‚îÄ collection
‚îÇ   ‚îî‚îÄ repository (user's DID)
‚îî‚îÄ protocol
```

## Swift Implementation

### Models
```swift
struct StrongRef: Codable {
    let uri: String
    let cid: String
}

struct CheckinRecord: Codable {
    let type = "app.dropanchor.checkin"
    let text: String
    let createdAt: String
    let addressRef: StrongRef
    let coordinates: GeoCoordinates
    
    private enum CodingKeys: String, CodingKey {
        case type = "$type"
        case text, createdAt, addressRef, coordinates
    }
}
```

### Service Implementation
```swift
class CheckinService {
    func createCheckinWithAddress(
        text: String,
        address: AddressInfo,
        coordinates: GeoCoordinates
    ) async throws -> String {
        
        // Step 1: Create address record
        let addressRecord = CommunityAddress(
            name: address.name,
            street: address.street,
            locality: address.locality,
            region: address.region,
            country: address.country,
            postalCode: address.postalCode
        )
        
        let addressResponse = try await atproto.createRecord(
            repo: userDid,
            collection: "community.lexicon.location.address",
            record: addressRecord
        )
        
        // Step 2: Create checkin with strongref
        let checkinRecord = CheckinRecord(
            text: text,
            createdAt: ISO8601DateFormatter().string(from: Date()),
            addressRef: StrongRef(
                uri: addressResponse.uri,
                cid: addressResponse.cid
            ),
            coordinates: coordinates
        )
        
        do {
            let checkinResponse = try await atproto.createRecord(
                repo: userDid,
                collection: "app.dropanchor.checkin",
                record: checkinRecord
            )
            
            return checkinResponse.uri
            
        } catch {
            // Cleanup: delete orphaned address record
            try? await atproto.deleteRecord(
                repo: userDid,
                collection: "community.lexicon.location.address", 
                rkey: extractRkey(from: addressResponse.uri)
            )
            throw error
        }
    }
}
```

## Resolution & Verification

### Reading Checkins
```swift
func resolveCheckin(uri: String) async throws -> ResolvedCheckin {
    // 1. Fetch checkin record
    let checkin = try await atproto.getRecord(uri: uri)
    
    // 2. Resolve address strongref  
    let address = try await atproto.getRecord(uri: checkin.addressRef.uri)
    
    // 3. Verify content integrity
    guard address.cid == checkin.addressRef.cid else {
        throw CheckinError.addressContentMismatch
    }
    
    return ResolvedCheckin(checkin: checkin, address: address)
}
```

### CID Verification Process
1. Fetch record from strongref URI
2. Compare returned CID with stored CID in strongref
3. If mismatch: address record has been modified since checkin creation
4. Handle gracefully (warn user, show cached data, etc.)

## Error Handling

### Atomic Creation
```swift
// Ensure both records are created or both fail
do {
    let addressUri = try await createAddressRecord(address)
    let checkinUri = try await createCheckinRecord(text, addressRef: addressUri)
    return checkinUri
} catch {
    // If checkin fails, cleanup address record
    if let addressUri = addressUri {
        try? await deleteRecord(addressUri)
    }
    throw error
}
```

### Common Error Cases
- Network failure between address and checkin creation
- Insufficient storage quota on PDS
- Invalid record format
- PDS temporarily unavailable

## Migration Strategy

### Phase 1: Dual Support
- Read both embedded address and strongref formats
- New checkins use strongref pattern
- Existing checkins unchanged

### Phase 2: Optional Migration
- User-initiated conversion tool
- Migrate old checkins to new format
- Preserve all timestamps and metadata

## Benefits

‚úÖ **Self-contained:** All data on user's PDS  
‚úÖ **Content integrity:** CID verification prevents tampering  
‚úÖ **Reusable addresses:** Same venue can be referenced multiple times  
‚úÖ **Standards compliant:** Uses community lexicon properly  
‚úÖ **Future-proof:** Supports address record evolution

## Tradeoffs

‚ö†Ô∏è **Two API calls** to create each checkin  
‚ö†Ô∏è **Two fetches** to display complete checkin data  
‚ö†Ô∏è **Storage overhead** from separate records  
‚ö†Ô∏è **Atomic operation complexity**

## Implementation Checklist

- [ ] Define StrongRef and record models
- [ ] Implement atomic creation service
- [ ] Add CID verification logic  
- [ ] Handle cleanup on creation failure
- [ ] Support reading both old and new formats
- [ ] Test error scenarios thoroughly
- [ ] Create migration tool for existing data